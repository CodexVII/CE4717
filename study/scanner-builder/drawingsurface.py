###########################################################################################
##
## Device-specific drawing routines, encapsulated as subclasses of the abstract base
## class "DrawingSurface".  Put device-drivers for different classes of output device
## in here.
##
## DrawingSurface: Simply an abstract base class for all device-driver drawing classes.
##
import math
from Tkinter import *

class DrawingSurface(object):
    pass

##-------------------------------------------------------------------
##
## TkDrawing: a class that draws an automaton on a Tk canvas widget.
##
## Use: Simply create a TkDrawing object with a finite-automaton
## as argument:
##
## >>> TkDrawing(nfa3)
##
## The finite-automaton should be, for example, an NFA object (or
## an object created from an NFA subclass).
##
class TkDrawing(DrawingSurface):
    SCALE = 4
    OFFSET = 20
    
    def __init__(this,automaton):
        this.automaton = automaton
        this.root = Tk()
        this.canvas = Canvas(width  = TkDrawing.SCALE*automaton.width + 2 * TkDrawing.OFFSET,
                             height = TkDrawing.SCALE*automaton.height + 2 * TkDrawing.OFFSET,
                             bg='white', master=this.root)
        this.canvas.pack(expand=YES, fill=BOTH)
        this.automaton.draw(this)
        this.canvas.mainloop()
        ##this.root.destroy()
        
    def drawArrow(this, x1, y1, x2, y2):
        x1 = x1 * TkDrawing.SCALE + TkDrawing.OFFSET
        x2 = x2 * TkDrawing.SCALE + TkDrawing.OFFSET
        y1 = (this.automaton.height - y1) * TkDrawing.SCALE + TkDrawing.OFFSET
        y2 = (this.automaton.height - y2) * TkDrawing.SCALE + TkDrawing.OFFSET
        this.canvas.create_line(x1, y1, x2, y2, arrow=LAST)

    def drawCircle(this, x, y, radius):
        y = this.automaton.height - y
        x1 = (x - radius) * TkDrawing.SCALE + TkDrawing.OFFSET
        x2 = (x + radius) * TkDrawing.SCALE + TkDrawing.OFFSET
        y1 = (y - radius) * TkDrawing.SCALE + TkDrawing.OFFSET
        y2 = (y + radius) * TkDrawing.SCALE + TkDrawing.OFFSET
        this.canvas.create_oval(x1, y1, x2, y2, fill='white')

    def drawText(this, x, y, string, pos=None):
        x = x * TkDrawing.SCALE + TkDrawing.OFFSET
        y = (this.automaton.height - y) * TkDrawing.SCALE + TkDrawing.OFFSET
        if pos and pos == 'above': y -= 6 ## nudge y up a little for y-'above' drawing.
        this.canvas.create_text(x, y, text=string)

    def drawCurve(this, sx, sy, cp1x, cp1y, cp2x, cp2y, ex, ey):
        sx   = sx * TkDrawing.SCALE + TkDrawing.OFFSET
        cp1x = cp1x * TkDrawing.SCALE + TkDrawing.OFFSET
        cp2x = cp2x * TkDrawing.SCALE + TkDrawing.OFFSET
        ex   = ex * TkDrawing.SCALE + TkDrawing.OFFSET
        sy   = (this.automaton.height - sy) * TkDrawing.SCALE + TkDrawing.OFFSET
        cp1y = (this.automaton.height - cp1y) * TkDrawing.SCALE + TkDrawing.OFFSET
        cp2y = (this.automaton.height - cp2y) * TkDrawing.SCALE + TkDrawing.OFFSET
        ey   = (this.automaton.height - ey) * TkDrawing.SCALE + TkDrawing.OFFSET    
        this.canvas.create_line(sx,sy,cp1x,cp1y,cp2x,cp2y,ex,ey, arrow=LAST, smooth=1)



##-------------------------------------------------------------------
##
## PostScript: a class that generates a PostScript representation of
##              finite-automaton graph.
##
## Use: Simply create a PostScript object with an automaton and a 
## filename as arguments:
##
## >>> PostScript(nfa3,"nfa3.ps")
##
## The generated PostScript can be converted to pdf using "ps2pdf".
## It contains a CropBox, so that the final pdf is (noramlly)
## correctly clipped.
##
## N.B., it may be necessary to specify a large paper
## size to ps2pdf, otherwise, if the width of the graph is wider
## than 210mm (the default A4 paper width built in to ghostscript),
## the graph will be cropped at this width regardless of the settings
## of the CropBox and BoundingBox in the PostScript output.  There
## should be a way to fix this in the generated PostScript, but I
## can't find it, so the proposed current solution is to specify
## a very wide paper size in the ps2pdf call, e.g.,
##
##   $ ps2pdf -sPAPERSIZE=a0 nfagraph.eps
##
## (where "nfagraph.eps" is the file containing PostScript code
## generated by this routine).
##        

class PostScript(DrawingSurface):
    SCALE = 72.0 / 25.4   ## Postscript points to millimeters scaling.
    OFFSET = 10.0         ## Put a 10-pt border around the drawing.
    R2D = 180.0 / math.pi
    
    def __init__(this,automaton,outputFileName=None):
        this.automaton = automaton
        old_outputstream = sys.stdout
        try:
            if outputFileName and isinstance(outputFileName,str):
                print "Attempting to open file", outputFileName
                new_outputstream = open(outputFileName, "w")
                print new_outputstream
                sys.stdout = new_outputstream
            this.outputPreamble()
            this.automaton.draw(this)
            if outputFileName:
                sys.stdout = old_outputstream
                new_outputstream.close()
        except IOError:
            print "Output problem", IOError
            sys.stdout = old_outputstream

    def outputPreamble(this):
        print ("%!EPSF-3.0")
        w = PostScript.SCALE * this.automaton.width + 2 * PostScript.OFFSET
        h = PostScript.SCALE * this.automaton.height  + 2 * PostScript.OFFSET
        print ("%sBoundingBox: 0 0 %d %d" % ("%%",w,h))
        print ("%sCropBox: 0 0 %d %d" % ("%%",w,h))
        print ("%sDocumentFonts: Times-Roman" % "%%")
        print ("%sEndComments" % "%%")
        print ("[ /CropBox [ 0 0 %d %d ] /PAGES pdfmark" % (w,h)) 

    def drawArrow(this, x1, y1, x2, y2):
        x = x1 * PostScript.SCALE + PostScript.OFFSET
        y = y1 * PostScript.SCALE + PostScript.OFFSET
        length = math.sqrt((y2-y1)**2+(x2-x1)**2) * PostScript.SCALE
        angle = PostScript.R2D * math.atan2(y2-y1, x2-x1)
        print ("gsave %f %f translate %f rotate" % (x,y,angle))
        print ("newpath 0 0 moveto %f 0 lineto stroke" % (length-3))
        print ("%f 0 translate" % length )
        print ("newpath 0 0 moveto -7.5 3 rlineto 3 -3 rlineto -3 -3 rlineto")
        print ("closepath fill grestore")
        
    def drawCircle(this, x, y, radius):
        x = x * PostScript.SCALE + PostScript.OFFSET
        y = y * PostScript.SCALE + PostScript.OFFSET
        radius *= PostScript.SCALE
        print ("1 setgray")
        print ("newpath %f %f %f 0 360 arc fill" % (x,y,radius))
        print ("0 setgray")
        print ("newpath %f %f %f 0 360 arc stroke" % (x,y,radius))

    def drawText(this, x, y, string, pos = None):
        x = x * PostScript.SCALE + PostScript.OFFSET
        y = y * PostScript.SCALE + PostScript.OFFSET
        print ("/Times-Roman findfont 12 scalefont setfont")
        print ("newpath %f %f moveto" % (x,y))
        if pos and pos == 'above':  ## nudge y up a little for x-centred, y-'above' drawing
            y_adjust = 4
        else:   ## otherwise, nudge y down for both x and y centred drawing
            y_adjust = -4        
        print ("(%s) dup stringwidth pop 2 div neg %d rmoveto show" % (string, y_adjust))

    def drawCurve(this, sx, sy, cp1x, cp1y, cp2x, cp2y, ex, ey):
        sx   = sx   * PostScript.SCALE + PostScript.OFFSET
        cp1x = cp1x * PostScript.SCALE + PostScript.OFFSET
        cp2x = cp2x * PostScript.SCALE + PostScript.OFFSET
        ex   = ex   * PostScript.SCALE + PostScript.OFFSET
        sy   = sy   * PostScript.SCALE + PostScript.OFFSET
        cp1y = cp1y * PostScript.SCALE + PostScript.OFFSET
        cp2y = cp2y * PostScript.SCALE + PostScript.OFFSET
        ey   = ey   * PostScript.SCALE + PostScript.OFFSET
        midx = (cp1x + cp2x) / 2.0
        midy = (cp1y + cp2y) / 2.0
        print ("newpath %f %f moveto %f %f %f %f %f %f curveto" %\
               (sx,sy,cp1x,cp1y,cp1x,cp1y,midx,midy))
        print ("%f %f %f %f %f %f curveto stroke" % (cp2x,cp2y,cp2x,cp2y,ex,ey))
        print ("newpath %f %f moveto" % (ex,ey))
        if cp2y > ey:  
            print ("3 7.5 rlineto -3 -3 rlineto -3 3 rlineto closepath fill")
        else:
            print ("3 -7.5 rlineto -3 3 rlineto -3 -3 rlineto closepath fill")
